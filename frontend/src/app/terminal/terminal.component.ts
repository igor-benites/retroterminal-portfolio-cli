import { Component, OnInit, Inject, PLATFORM_ID } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { isPlatformBrowser } from '@angular/common';

@Component({
  selector: 'app-terminal',
  templateUrl: './terminal.component.html',
  styleUrls: ['./terminal.component.css'],
})
export class TerminalComponent implements OnInit {
  chatHistory: string[] = [];
  commandHistory: string[] = [];
  currentCommandIndex: number = -1;
  isTyping: boolean = false; // Variable to control the typing animation state

  constructor(
    private http: HttpClient,
    @Inject(PLATFORM_ID) private platformId: Object
  ) {}

  ngOnInit(): void {
    this.chatHistory.push(
        '******************************************************************************* \n' +
        "Welcome to the portfolio! This is a professional website showcasing work and experience.\n" +
        'Explore the projects and feel free to ask questions.\n' +
        'Please note that the responses provided by this site are generated by an AI trained on the resume.\n' +
        'Thank you for your understanding and patience!\n\n' +
        "Type a question or a command below (e.g., 'help') to get started. \n" +
        '******************************************************************************* \n'
    );
    this.updateChat();
  }

  onCommandEntered(event: any) {
    if (this.isTyping) return; // If typing animation is in progress, do not allow new commands

    const command = event.target.value;
    this.chatHistory.push(`> ${command}`);
    event.target.value = '';

    this.commandHistory.push(command);
    this.currentCommandIndex = this.commandHistory.length;
    this.processCommand(command);
  }

  handleBasicCommands(command: string) {
    if (command.toLowerCase() === 'clear') {
      this.chatHistory = [];
      this.updateChat();
      return true;
    }

    if (command.toLowerCase() === 'help') {
      this.animateResponse('Available commands: clear, help, ls');
      return true;
    }

    if (command.toLowerCase() === 'ls') {
      this.animateResponse('About  Skills  Experience  Projects');
      return true;
    }

    if (command.toLowerCase() === 'neo') {
      this.animateResponse('Follow the white rabbit.');
      return true;
    }

    return false;
  }

  processCommand(command: string) {
    this.chatHistory.push('');
    this.updateChat();

    const loadingIndex = this.chatHistory.length - 1;
    let loadingDots = 0;

    // Typing animation for "Loading"
    const typingAnimation = setInterval(() => {
      loadingDots = (loadingDots + 1) % 4;
      this.chatHistory[loadingIndex] = 'Loading' + '.'.repeat(loadingDots);
      this.updateChat();
    }, 500);

    if (this.handleBasicCommands(command)) {
      clearInterval(typingAnimation);
      return;
    }

    // Send command to backend
    this.http
      .post(
        'http://localhost:5254/api/Chat/send-command',
        { command },
        { responseType: 'text' }
      )
      .subscribe({
        next: (response: string) => {
          this.animateResponse(response);
          clearInterval(typingAnimation);
        },
        error: (error) => {
          clearInterval(typingAnimation);
          this.animateResponse(
            'An error occurred while processing your command.'
          );
        },
      });
  }

  onKeyUp(event: KeyboardEvent, inputElement: EventTarget | null) {
    if (inputElement && inputElement instanceof HTMLInputElement) {
      // Arrow key navigation for command history
      if (event.key === 'ArrowUp') {
        if (this.currentCommandIndex > 0) {
          this.currentCommandIndex--;
          inputElement.value = this.commandHistory[this.currentCommandIndex];
        }
      } else if (event.key === 'ArrowDown') {
        if (this.currentCommandIndex < this.commandHistory.length - 1) {
          this.currentCommandIndex++;
          inputElement.value = this.commandHistory[this.currentCommandIndex];
        } else {
          this.currentCommandIndex = this.commandHistory.length;
          inputElement.value = '';
        }
      }
    }
  }

  // Function to animate the response
  animateResponse(response: string) {
    this.isTyping = true; // Disable input while animation is running
    const typingSpeed = 15;
    let index = 0;
    const responseIndex = this.chatHistory.length;
    this.chatHistory.push('');
    this.updateChat();

    const interval = setInterval(() => {
      this.chatHistory[responseIndex] = response.substring(0, index + 1);
      this.updateChat();

      index++;
      if (index === response.length) {
        clearInterval(interval);
        this.isTyping = false; // Re-enable input after animation ends
      }
    }, typingSpeed);
  }

  updateChat() {
    if (isPlatformBrowser(this.platformId)) {
      const terminal = document.getElementById('chat-output');
      if (terminal) {
        terminal.innerText = this.chatHistory.join('\n');

        // Add add scroll
        terminal.scrollTop = terminal.scrollHeight;
      }
    }
  }
}
